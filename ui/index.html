<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Floppy Explorer</title>
<link rel="icon" type="image/png" href="/icon-512.png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --amber: #FFB000;
  --amber-bright: #FFD866;
  --amber-dim: #B87800;
  --amber-ghost: rgba(255, 176, 0, 0.06);
  --amber-glow: rgba(255, 176, 0, 0.15);
  --amber-line: rgba(255, 176, 0, 0.12);
  --green: #44CC66;
  --green-dim: #2A7A3E;
  --yellow: #CCAA22;
  --red: #CC4444;
  --red-dim: #7A2A2A;
  --bg-deep: #060a10;
  --bg: #0a0e14;
  --bg-raised: #0f1520;
  --bg-surface: #131a24;
  --bg-hover: #182030;
  --border: rgba(255, 176, 0, 0.1);
  --border-bright: rgba(255, 176, 0, 0.25);
  --text: #C8A050;
  --text-dim: #6B5530;
  --text-bright: #E8C878;
  --font: 'JetBrains Mono', 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  --sidebar-w: 260px;
  --statusbar-h: 28px;
}

html, body {
  height: 100%;
  overflow: hidden;
  background: var(--bg-deep);
  color: var(--text);
  font-family: var(--font);
  font-size: 12px;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
}

/* ═══ Scanline overlay ═══ */
body::after {
  content: '';
  position: fixed;
  inset: 0;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0, 0, 0, 0.08) 2px,
    rgba(0, 0, 0, 0.08) 4px
  );
  pointer-events: none;
  z-index: 9999;
}

/* ═══ Scrollbars ═══ */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--amber-dim); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--amber); }
::-webkit-scrollbar-corner { background: var(--bg); }

/* ═══ App shell ═══ */
#app {
  display: grid;
  grid-template-columns: var(--sidebar-w) 1fr;
  grid-template-rows: 1fr var(--statusbar-h);
  height: 100vh;
  width: 100vw;
}

/* ═══ Sidebar ═══ */
#sidebar {
  grid-row: 1 / -1;
  background: var(--bg);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
}

#sidebar::after {
  content: '';
  position: absolute;
  right: 0; top: 0; bottom: 0;
  width: 1px;
  background: linear-gradient(180deg, transparent, var(--amber-glow) 30%, var(--amber-glow) 70%, transparent);
  pointer-events: none;
}

/* Logo area */
.logo-area {
  padding: 16px 16px 12px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.logo-title {
  font-size: 15px;
  font-weight: 700;
  color: var(--amber);
  letter-spacing: 1.5px;
  text-transform: uppercase;
  text-shadow: 0 0 20px rgba(255, 176, 0, 0.4), 0 0 40px rgba(255, 176, 0, 0.15);
  line-height: 1;
}

.logo-sub {
  font-size: 9px;
  color: var(--text-dim);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-top: 4px;
}

/* GW device panel */
.gw-panel {
  padding: 12px 16px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.gw-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.gw-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--red-dim);
  flex-shrink: 0;
  transition: all 0.3s;
}

.gw-indicator.connected {
  background: var(--green);
  box-shadow: 0 0 8px rgba(68, 204, 102, 0.6);
}

.gw-label {
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text-dim);
}

.gw-info {
  font-size: 10px;
  color: var(--text-dim);
  line-height: 1.6;
}

.gw-info span {
  color: var(--text);
}

/* Read disk button */
.read-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  width: calc(100% - 32px);
  margin: 0 16px 12px;
  padding: 8px 12px;
  background: linear-gradient(180deg, rgba(255, 176, 0, 0.12), rgba(255, 176, 0, 0.06));
  border: 1px solid var(--border-bright);
  border-radius: 4px;
  color: var(--amber);
  font-family: var(--font);
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.2s;
  flex-shrink: 0;
}

.read-btn:hover:not(:disabled) {
  background: linear-gradient(180deg, rgba(255, 176, 0, 0.2), rgba(255, 176, 0, 0.1));
  border-color: var(--amber);
  text-shadow: 0 0 10px rgba(255, 176, 0, 0.5);
}

.read-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.read-btn svg {
  width: 14px;
  height: 14px;
  fill: currentColor;
}

/* Read progress */
.read-progress {
  display: none;
  margin: 0 16px 12px;
  padding: 8px 10px;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 10px;
  color: var(--text-dim);
  max-height: 80px;
  overflow-y: auto;
}

.read-progress.active {
  display: block;
}

.read-progress .line {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.read-progress .line:last-child {
  color: var(--amber);
}

/* Disk list */
.disk-list-header {
  padding: 8px 16px;
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text-dim);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.disk-list-header .count {
  color: var(--amber-dim);
}

.disk-list {
  flex: 1;
  overflow-y: auto;
  padding: 4px 0;
}

.disk-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 16px;
  cursor: pointer;
  transition: background 0.15s;
  border-left: 2px solid transparent;
}

.disk-item:hover {
  background: var(--bg-hover);
}

.disk-item.active {
  background: var(--amber-ghost);
  border-left-color: var(--amber);
}

.disk-icon {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
  opacity: 0.5;
}

.disk-item.active .disk-icon { opacity: 0.9; }

.disk-name {
  flex: 1;
  font-size: 11px;
  color: var(--text-bright);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.disk-item.active .disk-name { color: var(--amber); }

.disk-meta {
  font-size: 9px;
  color: var(--text-dim);
  text-align: right;
  flex-shrink: 0;
}

.disk-badge {
  display: inline-block;
  padding: 1px 4px;
  font-size: 8px;
  font-weight: 600;
  letter-spacing: 0.5px;
  border-radius: 2px;
  background: rgba(255, 176, 0, 0.1);
  color: var(--amber-dim);
  margin-top: 2px;
}

.disk-item.active .disk-badge {
  background: rgba(255, 176, 0, 0.15);
  color: var(--amber);
}

/* Upload zone */
.upload-zone {
  margin: 8px 16px 16px;
  padding: 12px;
  border: 1px dashed var(--border-bright);
  border-radius: 4px;
  text-align: center;
  font-size: 10px;
  color: var(--text-dim);
  cursor: pointer;
  transition: all 0.2s;
  flex-shrink: 0;
}

.upload-zone:hover, .upload-zone.dragover {
  border-color: var(--amber);
  background: var(--amber-ghost);
  color: var(--amber-dim);
}

.upload-zone input { display: none; }

/* ═══ Main area ═══ */
#main {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: var(--bg-deep);
}

/* Empty state */
.empty-state {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
  color: var(--text-dim);
}

.empty-state svg { width: 64px; height: 64px; opacity: 0.15; }

.empty-state .msg {
  font-size: 13px;
  letter-spacing: 1px;
}

.empty-state .hint {
  font-size: 10px;
  opacity: 0.6;
}

/* Disk header bar */
.disk-header {
  display: none;
  padding: 10px 16px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  gap: 16px;
  align-items: center;
}

.disk-header.visible {
  display: flex;
}

.disk-header .dh-name {
  font-size: 14px;
  font-weight: 600;
  color: var(--amber);
  text-shadow: 0 0 15px rgba(255, 176, 0, 0.3);
}

.disk-header .dh-tags {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}

.tag {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 8px;
  font-size: 10px;
  font-weight: 500;
  border-radius: 3px;
  letter-spacing: 0.5px;
}

.tag-format {
  background: rgba(255, 176, 0, 0.12);
  color: var(--amber);
  border: 1px solid rgba(255, 176, 0, 0.2);
}

.tag-fs {
  background: rgba(68, 204, 102, 0.1);
  color: var(--green);
  border: 1px solid rgba(68, 204, 102, 0.2);
}

.tag-geo {
  background: rgba(255, 176, 0, 0.06);
  color: var(--text);
  border: 1px solid var(--border);
}

.dh-spacer { flex: 1; }

.dh-creator {
  font-size: 10px;
  color: var(--text-dim);
}

/* Tab bar */
.tab-bar {
  display: none;
  padding: 0 16px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  gap: 0;
}

.tab-bar.visible { display: flex; }

.tab-btn {
  padding: 8px 16px;
  font-family: var(--font);
  font-size: 10px;
  font-weight: 500;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text-dim);
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  cursor: pointer;
  transition: all 0.15s;
}

.tab-btn:hover { color: var(--text); }

.tab-btn.active {
  color: var(--amber);
  border-bottom-color: var(--amber);
}

/* Tab content */
.tab-content {
  flex: 1;
  overflow: hidden;
  display: none;
}

.tab-content.active { display: flex; flex-direction: column; }

/* ═══ Track Map ═══ */
.track-map-container {
  flex: 1;
  overflow: auto;
  display: flex;
  flex-direction: column;
}

.track-map-wrap {
  padding: 12px 16px;
  flex-shrink: 0;
}

.track-map-label {
  font-size: 10px;
  color: var(--text-dim);
  letter-spacing: 1px;
  text-transform: uppercase;
  margin-bottom: 8px;
}

.track-map {
  display: flex;
  flex-direction: column;
  gap: 2px;
  position: relative;
}

.track-map-side-label {
  font-size: 9px;
  color: var(--text-dim);
  margin-bottom: 3px;
  letter-spacing: 0.5px;
}

.track-row {
  display: flex;
  gap: 2px;
  flex-wrap: wrap;
}

.track-cell {
  width: 13px;
  height: 13px;
  border-radius: 2px;
  cursor: pointer;
  transition: all 0.12s;
  position: relative;
}

.track-cell.ok { background: var(--green-dim); }
.track-cell.ok:hover { background: var(--green); box-shadow: 0 0 6px rgba(68, 204, 102, 0.5); }
.track-cell.error { background: #7A6A2A; }
.track-cell.error:hover { background: var(--yellow); box-shadow: 0 0 6px rgba(204, 170, 34, 0.5); }
.track-cell.bad { background: var(--red-dim); }
.track-cell.bad:hover { background: var(--red); box-shadow: 0 0 6px rgba(204, 68, 68, 0.5); }
.track-cell.missing { background: var(--bg-surface); opacity: 0.4; cursor: default; }
.track-cell.selected {
  outline: 2px solid var(--amber);
  outline-offset: 1px;
  z-index: 1;
}

/* Track map tooltip */
.track-map-tooltip {
  position: fixed;
  padding: 4px 8px;
  background: var(--bg-surface);
  border: 1px solid var(--border-bright);
  border-radius: 3px;
  font-size: 10px;
  color: var(--amber);
  pointer-events: none;
  z-index: 100;
  white-space: nowrap;
  display: none;
  box-shadow: 0 2px 10px rgba(0,0,0,0.5);
}

/* ═══ Sector table + hex split ═══ */
.sector-hex-split {
  flex: 1;
  display: flex;
  border-top: 1px solid var(--border);
  min-height: 0;
}

.sector-panel {
  width: 340px;
  flex-shrink: 0;
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.sector-panel-header {
  padding: 8px 12px;
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text-dim);
  border-bottom: 1px solid var(--border);
  background: var(--bg);
  flex-shrink: 0;
}

.sector-table-wrap {
  flex: 1;
  overflow-y: auto;
}

table.sector-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 11px;
}

.sector-table th {
  position: sticky;
  top: 0;
  background: var(--bg-raised);
  padding: 5px 8px;
  text-align: left;
  font-size: 9px;
  font-weight: 600;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  color: var(--text-dim);
  border-bottom: 1px solid var(--border);
  white-space: nowrap;
}

.sector-table td {
  padding: 4px 8px;
  border-bottom: 1px solid var(--border);
  white-space: nowrap;
  color: var(--text);
}

.sector-table tr {
  cursor: pointer;
  transition: background 0.1s;
}

.sector-table tbody tr:hover {
  background: var(--bg-hover);
}

.sector-table tbody tr.active {
  background: var(--amber-ghost);
}

.sector-table tbody tr.active td {
  color: var(--amber);
}

.sector-flag {
  display: inline-block;
  padding: 0 4px;
  font-size: 8px;
  font-weight: 600;
  border-radius: 2px;
  letter-spacing: 0.3px;
}

.sector-flag.err {
  background: rgba(204, 68, 68, 0.15);
  color: var(--red);
}

.sector-flag.ok {
  color: var(--green-dim);
}

/* ═══ Hex viewer ═══ */
.hex-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  min-width: 0;
}

.hex-panel-header {
  padding: 8px 12px;
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text-dim);
  border-bottom: 1px solid var(--border);
  background: var(--bg);
  flex-shrink: 0;
  display: flex;
  align-items: center;
  gap: 12px;
}

.hex-panel-header .sector-id {
  color: var(--amber);
}

.hex-viewer {
  flex: 1;
  overflow: auto;
  padding: 6px 0;
  background: var(--bg-deep);
  font-size: 11px;
  line-height: 1.7;
}

.hex-line {
  display: flex;
  padding: 0 12px;
  white-space: pre;
  transition: background 0.08s;
}

.hex-line:hover {
  background: var(--bg-hover);
}

.hex-offset {
  color: var(--text-dim);
  width: 64px;
  flex-shrink: 0;
  user-select: none;
}

.hex-bytes {
  color: var(--text);
  flex-shrink: 0;
  width: 400px;
  letter-spacing: 0.3px;
}

.hex-bytes .zero { color: var(--text-dim); opacity: 0.4; }
.hex-bytes .hi { color: var(--amber); }

.hex-ascii {
  color: var(--amber-dim);
  border-left: 1px solid var(--border);
  padding-left: 12px;
  margin-left: 8px;
}

.hex-ascii .dot { color: var(--text-dim); opacity: 0.3; }

.hex-empty {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-dim);
  font-size: 11px;
  opacity: 0.5;
}

/* ═══ File browser ═══ */
.file-browser {
  flex: 1;
  overflow: auto;
  padding: 0;
}

table.file-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 11px;
}

.file-table th {
  position: sticky;
  top: 0;
  background: var(--bg-raised);
  padding: 6px 12px;
  text-align: left;
  font-size: 9px;
  font-weight: 600;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  color: var(--text-dim);
  border-bottom: 1px solid var(--border);
}

.file-table td {
  padding: 5px 12px;
  border-bottom: 1px solid var(--border);
  color: var(--text);
}

.file-table .fname { color: var(--amber-bright); }
.file-table .fdir { color: var(--green); }
.dir-icon { vertical-align: -1px; margin-right: 3px; color: var(--green); }
.file-table .fhidden { opacity: 0.45; }
.file-table .fvol {
  color: var(--amber);
  font-weight: 600;
  letter-spacing: 0.5px;
}

.file-table .fsize {
  text-align: right;
  color: var(--text-dim);
  font-variant-numeric: tabular-nums;
}

.file-table .fdate {
  color: var(--text-dim);
  white-space: nowrap;
}

.file-table .attr-flags {
  font-size: 9px;
  color: var(--text-dim);
  letter-spacing: 0.5px;
}

.sfn-alias {
  display: block;
  font-size: 9px;
  color: var(--text-dim);
  opacity: 0.6;
  margin-top: 1px;
}

.dl-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 22px;
  height: 22px;
  font-size: 14px;
  color: var(--amber-dim);
  text-decoration: none;
  border-radius: 3px;
  transition: all 0.15s;
}

.dl-btn:hover {
  color: var(--amber);
  background: rgba(255, 176, 0, 0.1);
  text-shadow: 0 0 8px rgba(255, 176, 0, 0.4);
}

.fdl { width: 30px; text-align: center; }

.dl-all-btn {
  background: rgba(255, 176, 0, 0.08);
  border: 1px solid var(--amber-dim);
  color: var(--amber);
  font-family: var(--font);
  font-size: 9px;
  padding: 1px 6px;
  border-radius: 3px;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}
.dl-all-btn:hover {
  background: rgba(255, 176, 0, 0.15);
  border-color: var(--amber);
  text-shadow: 0 0 8px rgba(255, 176, 0, 0.4);
}

.dir-icon {
  display: inline-block;
  width: 12px;
  height: 10px;
  margin-right: 3px;
  vertical-align: -1px;
}

.no-files {
  padding: 32px;
  text-align: center;
  color: var(--text-dim);
  font-size: 11px;
}

/* ═══ Status bar ═══ */
#statusbar {
  grid-column: 2;
  background: var(--bg);
  border-top: 1px solid var(--border);
  padding: 0 16px;
  display: flex;
  align-items: center;
  gap: 16px;
  font-size: 10px;
  color: var(--text-dim);
}

#statusbar .status-msg { flex: 1; }
#statusbar .status-stats { text-align: right; }
#statusbar .status-stats span { color: var(--text); }

/* ═══ Read disk modal ═══ */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal-overlay.visible { display: flex; }

.modal {
  background: var(--bg-surface);
  border: 1px solid var(--border-bright);
  border-radius: 6px;
  padding: 20px 24px;
  width: 380px;
  max-width: 90vw;
}

.modal h3 {
  font-size: 13px;
  font-weight: 600;
  color: var(--amber);
  letter-spacing: 1px;
  text-transform: uppercase;
  margin-bottom: 16px;
  text-shadow: 0 0 15px rgba(255, 176, 0, 0.3);
}

.modal label {
  display: block;
  font-size: 10px;
  color: var(--text-dim);
  letter-spacing: 0.5px;
  text-transform: uppercase;
  margin-bottom: 4px;
  margin-top: 12px;
}

.modal label:first-of-type { margin-top: 0; }

.modal input, .modal select {
  width: 100%;
  padding: 6px 10px;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text-bright);
  font-family: var(--font);
  font-size: 11px;
  outline: none;
}

.modal input:focus, .modal select:focus {
  border-color: var(--amber-dim);
}

.modal-actions {
  display: flex;
  gap: 8px;
  margin-top: 20px;
  justify-content: flex-end;
}

.modal-actions button {
  padding: 6px 16px;
  font-family: var(--font);
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  border-radius: 3px;
  cursor: pointer;
  border: 1px solid var(--border);
  transition: all 0.15s;
}

.btn-cancel {
  background: var(--bg);
  color: var(--text-dim);
}

.btn-cancel:hover { background: var(--bg-hover); color: var(--text); }

.btn-primary {
  background: linear-gradient(180deg, rgba(255, 176, 0, 0.15), rgba(255, 176, 0, 0.08));
  border-color: var(--amber-dim);
  color: var(--amber);
}

.btn-primary:hover {
  background: linear-gradient(180deg, rgba(255, 176, 0, 0.25), rgba(255, 176, 0, 0.12));
  border-color: var(--amber);
  text-shadow: 0 0 10px rgba(255, 176, 0, 0.5);
}

/* ═══ Context menu ═══ */
.ctx-menu {
  position: fixed;
  background: var(--bg-surface);
  border: 1px solid var(--border-bright);
  border-radius: 4px;
  padding: 4px 0;
  min-width: 140px;
  z-index: 2000;
  display: none;
  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
}

.ctx-menu.visible { display: block; }

.ctx-menu-item {
  padding: 6px 14px;
  font-size: 11px;
  color: var(--text);
  cursor: pointer;
  transition: background 0.1s;
}

.ctx-menu-item:hover {
  background: var(--amber-ghost);
  color: var(--amber);
}

.ctx-menu-item.danger { color: var(--red); }
.ctx-menu-item.danger:hover { background: rgba(204, 68, 68, 0.1); }

/* ═══ Animations ═══ */
@keyframes pulse-glow {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}

.reading .read-btn {
  animation: pulse-glow 1.5s ease-in-out infinite;
}

/* No-select on UI chrome */
.logo-area, .gw-panel, .disk-list-header, .track-map-label,
.sector-panel-header, .hex-panel-header, .tab-bar, #statusbar {
  user-select: none;
}
</style>
</head>
<body>

<div id="app">
  <!-- ═══ Sidebar ═══ -->
  <div id="sidebar">
    <div class="logo-area">
      <div class="logo-title">Floppy Explorer</div>
      <div class="logo-sub">EDSK Image Analyzer</div>
    </div>

    <div class="gw-panel">
      <div class="gw-header">
        <div class="gw-indicator" id="gw-indicator"></div>
        <div class="gw-label">Greaseweazle</div>
      </div>
      <div class="gw-info" id="gw-info">Checking device...</div>
    </div>

    <button class="read-btn" id="read-btn" disabled>
      <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z"/></svg>
      Read Disk
    </button>

    <div class="read-progress" id="read-progress"></div>

    <div class="disk-list-header">
      <span>Disk Images</span>
      <span class="count" id="disk-count">0</span>
    </div>

    <div class="disk-list" id="disk-list"></div>

    <div class="upload-zone" id="upload-zone">
      Drop .edsk / .dsk files here
      <input type="file" id="upload-input" accept=".edsk,.dsk,.img,.ima" multiple>
    </div>
  </div>

  <!-- ═══ Main area ═══ -->
  <div id="main">
    <div class="disk-header" id="disk-header">
      <span class="dh-name" id="dh-name"></span>
      <div class="dh-tags" id="dh-tags"></div>
      <div class="dh-spacer"></div>
      <span class="dh-creator" id="dh-creator"></span>
    </div>

    <div class="tab-bar" id="tab-bar">
      <button class="tab-btn active" data-tab="tracks">Tracks</button>
      <button class="tab-btn" data-tab="files">Files</button>
    </div>

    <!-- Empty state -->
    <div class="empty-state" id="empty-state">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-12.5c-2.49 0-4.5 2.01-4.5 4.5s2.01 4.5 4.5 4.5 4.5-2.01 4.5-4.5-2.01-4.5-4.5-4.5zm0 5.5c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"/></svg>
      <div class="msg">Select a disk image to explore</div>
      <div class="hint">or read a physical disk with Greaseweazle</div>
    </div>

    <!-- Tab: Tracks -->
    <div class="tab-content active" id="tab-tracks">
      <div class="track-map-container">
        <div class="track-map-wrap" id="track-map-wrap"></div>

        <div class="sector-hex-split">
          <div class="sector-panel">
            <div class="sector-panel-header" id="sector-panel-header">Select a track</div>
            <div class="sector-table-wrap" id="sector-table-wrap"></div>
          </div>

          <div class="hex-panel">
            <div class="hex-panel-header">
              <span>Hex Viewer</span>
              <span class="sector-id" id="hex-sector-id"></span>
            </div>
            <div class="hex-viewer" id="hex-viewer">
              <div class="hex-empty">Select a sector to view data</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Tab: Files -->
    <div class="tab-content" id="tab-files">
      <div class="file-browser" id="file-browser">
        <div class="no-files">No filesystem detected</div>
      </div>
    </div>
  </div>

  <!-- ═══ Status bar ═══ -->
  <div id="statusbar">
    <span class="status-msg" id="status-msg">Ready</span>
    <span class="status-stats" id="status-stats"></span>
  </div>
</div>

<!-- Read disk modal -->
<div class="modal-overlay" id="read-modal">
  <div class="modal">
    <h3>Read Physical Disk</h3>
    <label>Filename</label>
    <input type="text" id="read-filename" placeholder="my_disk.edsk">
    <label>Format (optional)</label>
    <select id="read-format">
      <option value="">Auto-detect</option>
      <option value="ibm.1440">IBM 1.44MB (HD)</option>
      <option value="ibm.720">IBM 720K (DD)</option>
      <option value="ibm.360">IBM 360K</option>
      <option value="ibm.1200">IBM 1.2MB</option>
      <option value="ibm.scan">IBM Scan (unknown)</option>
    </select>
    <label>Revolutions</label>
    <input type="number" id="read-revs" value="3" min="1" max="10">
    <label>Retries</label>
    <input type="number" id="read-retries" value="3" min="0" max="20">
    <div class="modal-actions">
      <button class="btn-cancel" id="read-cancel">Cancel</button>
      <button class="btn-primary" id="read-start">Start Read</button>
    </div>
  </div>
</div>

<!-- Context menu -->
<div class="ctx-menu" id="ctx-menu">
  <div class="ctx-menu-item" id="ctx-reload">Reload</div>
  <div class="ctx-menu-item danger" id="ctx-delete">Delete</div>
</div>

<!-- Track map tooltip -->
<div class="track-map-tooltip" id="track-tooltip"></div>

<script>
'use strict';

const API = `http://${location.hostname}:3141`;
const WS_URL = `ws://${location.hostname}:3141`;

// ═══ State ═══
const state = {
  disks: [],
  activeDisk: null,
  diskData: null,
  selectedTrack: null,
  selectedSector: null,
  gwConnected: false,
  reading: false,
  ws: null,
  ctxTarget: null,
};

// ═══ DOM refs ═══
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => document.querySelectorAll(sel);

const dom = {
  gwIndicator: $('#gw-indicator'),
  gwInfo: $('#gw-info'),
  readBtn: $('#read-btn'),
  readProgress: $('#read-progress'),
  diskCount: $('#disk-count'),
  diskList: $('#disk-list'),
  uploadZone: $('#upload-zone'),
  uploadInput: $('#upload-input'),
  main: $('#main'),
  diskHeader: $('#disk-header'),
  dhName: $('#dh-name'),
  dhTags: $('#dh-tags'),
  dhCreator: $('#dh-creator'),
  tabBar: $('#tab-bar'),
  emptyState: $('#empty-state'),
  tabTracks: $('#tab-tracks'),
  tabFiles: $('#tab-files'),
  trackMapWrap: $('#track-map-wrap'),
  sectorPanelHeader: $('#sector-panel-header'),
  sectorTableWrap: $('#sector-table-wrap'),
  hexSectorId: $('#hex-sector-id'),
  hexViewer: $('#hex-viewer'),
  fileBrowser: $('#file-browser'),
  statusMsg: $('#status-msg'),
  statusStats: $('#status-stats'),
  readModal: $('#read-modal'),
  readFilename: $('#read-filename'),
  readFormat: $('#read-format'),
  readRevs: $('#read-revs'),
  readRetries: $('#read-retries'),
  readCancel: $('#read-cancel'),
  readStart: $('#read-start'),
  ctxMenu: $('#ctx-menu'),
  ctxReload: $('#ctx-reload'),
  ctxDelete: $('#ctx-delete'),
};

// ═══ Helpers ═══
function hex(n, w = 2) {
  return '0x' + n.toString(16).toUpperCase().padStart(w, '0');
}

function formatSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / 1048576).toFixed(2) + ' MB';
}

async function api(path) {
  const res = await fetch(API + path);
  return res.json();
}

function setStatus(msg) {
  dom.statusMsg.textContent = msg;
}

// ═══ Greaseweazle ═══
async function checkGW() {
  try {
    const info = await api('/api/gw/info');
    state.gwConnected = info.connected;
    dom.gwIndicator.classList.toggle('connected', info.connected);

    if (info.connected) {
      if (info.busy) {
        dom.gwInfo.innerHTML = '<span style="color:var(--yellow)">Device busy — reading</span>';
        dom.readBtn.disabled = true;
      } else {
        dom.gwInfo.innerHTML = [
          info.host_tools ? `Host Tools: <span>${escHtml(info.host_tools)}</span>` : '',
          info.port ? `Device: Port: <span>${escHtml(info.port)}</span>` : '',
          info.model ? `Model: <span>${escHtml(info.model)}</span>` : '',
          info.mcu ? `MCU: <span>${escHtml(info.mcu)}</span>` : '',
          info.firmware ? `Firmware: <span>${escHtml(info.firmware)}</span>` : '',
          info.usb ? `USB: <span>${escHtml(info.usb)}</span>` : '',
        ].filter(Boolean).join('<br>');
        dom.readBtn.disabled = state.reading;
      }
    } else {
      dom.gwInfo.textContent = info.error || 'Not connected';
      dom.readBtn.disabled = true;
    }
  } catch (e) {
    state.gwConnected = false;
    dom.gwIndicator.classList.remove('connected');
    dom.gwInfo.textContent = 'Server offline';
    dom.readBtn.disabled = true;
  }
}

// ═══ WebSocket ═══
function connectWS() {
  if (state.ws) return;
  try {
    const ws = new WebSocket(WS_URL);
    state.ws = ws;

    ws.onopen = () => { /* connected */ };

    ws.onmessage = (e) => {
      const msg = JSON.parse(e.data);
      handleWSMessage(msg);
    };

    ws.onclose = () => {
      state.ws = null;
      setTimeout(connectWS, 3000);
    };

    ws.onerror = () => { /* will trigger onclose */ };
  } catch {
    setTimeout(connectWS, 3000);
  }
}

function wsSend(data) {
  if (state.ws?.readyState === WebSocket.OPEN) {
    state.ws.send(JSON.stringify(data));
  }
}

function handleWSMessage(msg) {
  switch (msg.type) {
    case 'read-start':
      dom.readProgress.classList.add('active');
      dom.readProgress.innerHTML = '<div class="line">Starting read...</div>';
      setStatus(`Reading disk: ${msg.filename}`);
      break;

    case 'read-progress':
      const line = document.createElement('div');
      line.className = 'line';
      line.textContent = msg.line;
      dom.readProgress.appendChild(line);
      dom.readProgress.scrollTop = dom.readProgress.scrollHeight;
      break;

    case 'read-complete':
      state.reading = false;
      document.body.classList.remove('reading');
      dom.readBtn.disabled = false;
      setStatus(`Read complete: ${msg.filename}`);
      setTimeout(() => {
        dom.readProgress.classList.remove('active');
      }, 3000);
      loadDiskList().then(() => {
        if (msg.filename) selectDisk(msg.filename);
      });
      break;

    case 'read-error':
      state.reading = false;
      document.body.classList.remove('reading');
      dom.readBtn.disabled = false;
      const errLine = document.createElement('div');
      errLine.className = 'line';
      errLine.style.color = 'var(--red)';
      errLine.textContent = 'ERROR: ' + msg.message;
      dom.readProgress.appendChild(errLine);
      setStatus('Read failed');
      break;

    case 'read-cancelled':
      state.reading = false;
      document.body.classList.remove('reading');
      dom.readBtn.disabled = false;
      setStatus('Read cancelled');
      break;
  }
}

// ═══ Disk list ═══
async function loadDiskList() {
  try {
    state.disks = await api('/api/disks');
  } catch {
    state.disks = [];
  }
  renderDiskList();
}

function renderDiskList() {
  dom.diskCount.textContent = state.disks.length;

  dom.diskList.innerHTML = state.disks.map(d => `
    <div class="disk-item${state.activeDisk === d.name ? ' active' : ''}"
         data-name="${d.name}"
         oncontextmenu="showCtxMenu(event, '${d.name}')">
      <svg class="disk-icon" viewBox="0 0 24 24" fill="currentColor">
        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14zm-7-2c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3 1.34 3 3 3zm-4-8h5V7H8v2z"/>
      </svg>
      <div>
        <div class="disk-name">${d.name}</div>
        <div class="disk-meta">
          ${formatSize(d.size)}
          ${d.format ? `<div class="disk-badge">${d.format}</div>` : d.valid === false ? '<div class="disk-badge" style="color:var(--red)">ERR</div>' : ''}
        </div>
      </div>
    </div>
  `).join('');

  dom.diskList.querySelectorAll('.disk-item').forEach(el => {
    el.addEventListener('click', () => selectDisk(el.dataset.name));
  });
}

// ═══ Select disk ═══
async function selectDisk(name) {
  if (state.activeDisk === name && state.diskData) return;
  state.activeDisk = name;
  state.selectedTrack = null;
  state.selectedSector = null;

  renderDiskList();
  setStatus(`Loading ${name}...`);

  try {
    state.diskData = await api(`/api/disk/${encodeURIComponent(name)}`);
  } catch (e) {
    setStatus(`Failed to load ${name}`);
    return;
  }

  const d = state.diskData;
  dom.emptyState.style.display = 'none';

  // Header
  dom.diskHeader.classList.add('visible');
  dom.dhName.textContent = d.name;
  dom.dhCreator.textContent = d.creator ? `Creator: ${d.creator}` : '';

  let tagsHtml = `<span class="tag tag-format">${d.format}</span>`;
  tagsHtml += `<span class="tag tag-geo">${d.tracks}T ${d.sides}S</span>`;
  if (d.filesystem?.type && d.filesystem.type !== 'unknown') {
    tagsHtml += `<span class="tag tag-fs">${d.filesystem.type}</span>`;
    if (d.filesystem.volumeLabel) {
      tagsHtml += `<span class="tag tag-fs">${d.filesystem.volumeLabel}</span>`;
    }
  }
  dom.dhTags.innerHTML = tagsHtml;

  // Tabs
  dom.tabBar.classList.add('visible');
  const hasFiles = d.filesystem?.type === 'FAT';
  dom.tabBar.querySelectorAll('.tab-btn')[1].style.display = hasFiles ? '' : 'none';

  // Track map
  renderTrackMap(d);

  // Sector panel reset
  dom.sectorPanelHeader.textContent = 'Select a track';
  dom.sectorTableWrap.innerHTML = '';
  dom.hexSectorId.textContent = '';
  dom.hexViewer.innerHTML = '<div class="hex-empty">Select a sector to view data</div>';

  // Files
  if (hasFiles) {
    loadFiles(name);
  } else {
    dom.fileBrowser.innerHTML = '<div class="no-files">No FAT filesystem detected</div>';
  }

  // Stats
  const totalSectors = d.trackIndex.reduce((s, t) => s + (t.sectorCount || 0), 0);
  const errorSectors = d.trackIndex.reduce((s, t) =>
    s + (t.sectors || []).filter(sec => sec.hasError).length, 0);
  const missingTracks = d.trackIndex.filter(t => t.missing).length;

  dom.statusStats.innerHTML =
    `Sectors: <span>${totalSectors}</span>` +
    (errorSectors ? ` | Errors: <span style="color:var(--red)">${errorSectors}</span>` : '') +
    (missingTracks ? ` | Missing: <span>${missingTracks}</span>` : '');

  setStatus(`Loaded ${name}`);
  switchTab(hasFiles ? 'files' : 'tracks');
}

// ═══ Track map ═══
function renderTrackMap(d) {
  let html = '<div class="track-map-label">Track Map</div>';

  for (let side = 0; side < d.sides; side++) {
    html += `<div class="track-map-side-label">Side ${side}</div>`;
    html += '<div class="track-row">';

    for (let track = 0; track < d.tracks; track++) {
      const t = d.trackIndex.find(x => x.track === track && x.side === side);
      let cls = 'missing';
      let title = `T${track} S${side}`;

      if (t && !t.missing) {
        const hasErrors = t.sectors?.some(s => s.hasError);
        const hasTrunc = t.sectors?.some(s => s.truncated);
        if (hasTrunc) {
          cls = 'bad';
          title += ' [truncated]';
        } else if (hasErrors) {
          cls = 'error';
          title += ' [errors]';
        } else {
          cls = 'ok';
        }
        title += ` (${t.sectorCount} sectors)`;
      } else {
        title += ' [missing]';
      }

      const selected = state.selectedTrack &&
        state.selectedTrack.track === track && state.selectedTrack.side === side;

      html += `<div class="track-cell ${cls}${selected ? ' selected' : ''}"
                    data-track="${track}" data-side="${side}"
                    data-tip="${title}"></div>`;
    }

    html += '</div>';
  }

  dom.trackMapWrap.innerHTML = html;

  const tooltip = $('#track-tooltip');
  dom.trackMapWrap.querySelectorAll('.track-cell').forEach(el => {
    if (!el.classList.contains('missing')) {
      el.addEventListener('click', () => {
        selectTrack(parseInt(el.dataset.track), parseInt(el.dataset.side));
      });
    }
    el.addEventListener('mouseenter', (e) => {
      tooltip.textContent = el.dataset.tip;
      tooltip.style.display = 'block';
      tooltip.style.left = (e.clientX + 12) + 'px';
      tooltip.style.top = (e.clientY - 8) + 'px';
    });
    el.addEventListener('mousemove', (e) => {
      tooltip.style.left = (e.clientX + 12) + 'px';
      tooltip.style.top = (e.clientY - 8) + 'px';
    });
    el.addEventListener('mouseleave', () => {
      tooltip.style.display = 'none';
    });
  });
}

// ═══ Select track ═══
function selectTrack(track, side) {
  state.selectedTrack = { track, side };
  state.selectedSector = null;

  // Update track map selection
  dom.trackMapWrap.querySelectorAll('.track-cell').forEach(el => {
    el.classList.toggle('selected',
      parseInt(el.dataset.track) === track && parseInt(el.dataset.side) === side);
  });

  const t = state.diskData.trackIndex.find(x => x.track === track && x.side === side);
  if (!t || t.missing) return;

  dom.sectorPanelHeader.textContent = `Track ${track}, Side ${side} — ${t.sectorCount} sectors`;

  let html = `<table class="sector-table">
    <thead><tr>
      <th>#</th><th>C</th><th>H</th><th>R</th><th>N</th><th>Size</th><th>Status</th>
    </tr></thead><tbody>`;

  for (const s of t.sectors) {
    const flags = s.hasError
      ? `<span class="sector-flag err">${s.errorFlags?.join(' ') || 'ERR'}</span>`
      : s.truncated
        ? '<span class="sector-flag err">TRUNC</span>'
        : '<span class="sector-flag ok">OK</span>';

    html += `<tr data-r="${s.R}" data-track="${track}" data-side="${side}">
      <td>${s.index}</td>
      <td>${s.C}</td><td>${s.H}</td>
      <td>${hex(s.R)}</td><td>${s.N}</td>
      <td>${s.size}</td>
      <td>${flags}</td>
    </tr>`;
  }

  html += '</tbody></table>';
  dom.sectorTableWrap.innerHTML = html;

  // Clear hex
  dom.hexSectorId.textContent = '';
  dom.hexViewer.innerHTML = '<div class="hex-empty">Select a sector to view data</div>';

  dom.sectorTableWrap.querySelectorAll('tbody tr').forEach(el => {
    el.addEventListener('click', () => {
      selectSector(
        parseInt(el.dataset.track),
        parseInt(el.dataset.side),
        parseInt(el.dataset.r)
      );
    });
  });
}

// ═══ Select sector ═══
async function selectSector(track, side, r) {
  state.selectedSector = { track, side, r };

  // Highlight active row
  dom.sectorTableWrap.querySelectorAll('tbody tr').forEach(el => {
    el.classList.toggle('active', parseInt(el.dataset.r) === r);
  });

  dom.hexSectorId.textContent = `T${track} S${side} R=${hex(r)}`;
  dom.hexViewer.innerHTML = '<div class="hex-empty">Loading...</div>';

  try {
    const data = await api(
      `/api/disk/${encodeURIComponent(state.activeDisk)}/sector?track=${track}&side=${side}&r=${r}`
    );
    renderHex(data);
  } catch (e) {
    dom.hexViewer.innerHTML = `<div class="hex-empty" style="color:var(--red)">Failed to load sector</div>`;
  }
}

// ═══ Hex renderer ═══
function renderHex(data) {
  if (!data.lines || data.lines.length === 0) {
    dom.hexViewer.innerHTML = '<div class="hex-empty">Empty sector</div>';
    return;
  }

  let html = '';
  for (const line of data.lines) {
    const offset = line.offset.toString(16).toUpperCase().padStart(6, '0');

    // Color hex bytes
    const hexParts = line.hex.split(' ').map(b => {
      if (b === '00') return '<span class="zero">00</span>';
      const v = parseInt(b, 16);
      if (v >= 0x80) return `<span class="hi">${b}</span>`;
      return b;
    }).join(' ');

    // Color ascii
    const asciiParts = line.ascii.split('').map(ch => {
      if (ch === '.') return '<span class="dot">.</span>';
      return ch;
    }).join('');

    html += `<div class="hex-line">` +
      `<span class="hex-offset">${offset}</span>` +
      `<span class="hex-bytes">${hexParts}</span>` +
      `<span class="hex-ascii">${asciiParts}</span>` +
      `</div>`;
  }

  dom.hexViewer.innerHTML = html;
}

// ═══ File browser ═══
function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

// Save a file extracted from a disk image (shows native save dialog)
async function saveFile(diskName, cluster, size, filename) {
  try {
    setStatus('Opening save dialog...');
    const url = `${API}/api/disk/${encodeURIComponent(diskName)}/save-file?cluster=${cluster}&size=${size}&name=${encodeURIComponent(filename)}`;
    const res = await fetch(url);
    const result = await res.json();
    if (result.cancelled) { setStatus('Save cancelled'); return; }
    if (result.saved) { setStatus('Saved to ' + result.path); return; }
    if (result.error) { setStatus('Save failed: ' + result.error); return; }
  } catch (e) {
    console.error('saveFile error:', e);
    setStatus('Save failed: ' + e.message);
  }
}

async function downloadAllFiles(diskName) {
  try {
    setStatus('Choose folder to save all files...');
    const res = await fetch(`${API}/api/disk/${encodeURIComponent(diskName)}/download-all`);
    if (!res.ok) throw new Error('Download failed');
    const result = await res.json();
    if (result.cancelled) { setStatus('Save cancelled'); return; }
    if (result.saved) {
      setStatus(`Saved ${result.count} files to ${result.path}`);
      return;
    }
    throw new Error(result.error || 'Unexpected response');
  } catch (e) {
    setStatus('Save all failed');
  }
}

async function loadFiles(name) {
  try {
    const files = await api(`/api/disk/${encodeURIComponent(name)}/files`);

    if (!files.length) {
      dom.fileBrowser.innerHTML = '<div class="no-files">Directory is empty</div>';
      return;
    }

    let html = `<table class="file-table">
      <thead><tr>
        <th>Name</th><th>Size</th><th>Date</th><th>Time</th><th>Attr</th>
        <th class="fdl"><button class="dl-all-btn" onclick="downloadAllFiles('${escHtml(name).replace(/'/g, "\\'")}')">All</button></th>
      </tr></thead><tbody>`;

    for (const f of files) {
      const cls = f.isVolumeLabel ? 'fvol' : f.isDir ? 'fdir' : f.isHidden ? 'fhidden' : 'fname';
      const attrs = [
        f.isReadOnly ? 'R' : '-',
        f.isHidden ? 'H' : '-',
        f.isSystem ? 'S' : '-',
        f.isDir ? 'D' : '-',
        f.isVolumeLabel ? 'V' : '-',
      ].join('');

      // Calculate depth from path for indentation
      const pathName = f.path || f.name;
      const depth = (pathName.match(/\//g) || []).length;
      const baseName = pathName.includes('/') ? pathName.split('/').pop() : pathName;
      const indent = depth > 0 ? `<span style="padding-left:${depth * 16}px"></span>` : '';
      const icon = f.isDir ? '<svg class="dir-icon" viewBox="0 0 16 14" width="13" height="11"><path d="M1 4V13H15V4H1Z" fill="rgba(255,176,0,0.12)" stroke="currentColor" stroke-width="1.1"/><path d="M1 4V2H6L8 4" fill="rgba(255,176,0,0.12)" stroke="currentColor" stroke-width="1.1"/></svg>' : '';

      // Show SFN as subtitle if LFN differs
      const displayLabel = f.isVolumeLabel ? '[' + escHtml(baseName) + ']' : escHtml(baseName);
      const sfnNote = (f.longName && f.shortName && f.shortName !== baseName)
        ? `<span class="sfn-alias">${escHtml(f.shortName)}</span>` : '';

      // Download link for regular files
      const canDownload = !f.isDir && !f.isVolumeLabel && f.size > 0 && f.cluster >= 2;
      const escapedName = escHtml(name).replace(/'/g, "\\'");
      const escapedBase = escHtml(baseName).replace(/'/g, "\\'");
      const dlLink = canDownload
        ? `<a class="dl-btn" href="#" onclick="saveFile('${escapedName}',${f.cluster},${f.size},'${escapedBase}');return false;" title="Save file">&#8681;</a>`
        : '';

      html += `<tr>
        <td class="${cls}">${indent}${icon}${displayLabel}${sfnNote}</td>
        <td class="fsize">${f.isDir || f.isVolumeLabel ? '' : formatSize(f.size)}</td>
        <td class="fdate">${f.date}</td>
        <td class="fdate">${f.time}</td>
        <td class="attr-flags">${attrs}</td>
        <td class="fdl">${dlLink}</td>
      </tr>`;
    }

    html += '</tbody></table>';
    dom.fileBrowser.innerHTML = html;
  } catch {
    dom.fileBrowser.innerHTML = '<div class="no-files">Failed to read directory</div>';
  }
}

// ═══ Tabs ═══
function switchTab(name) {
  $$('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === name));
  $$('.tab-content').forEach(c => c.classList.remove('active'));
  $(`#tab-${name}`).classList.add('active');
}

$$('.tab-btn').forEach(b => {
  b.addEventListener('click', () => switchTab(b.dataset.tab));
});

// ═══ Upload ═══
dom.uploadZone.addEventListener('click', () => dom.uploadInput.click());

dom.uploadZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dom.uploadZone.classList.add('dragover');
});

dom.uploadZone.addEventListener('dragleave', () => {
  dom.uploadZone.classList.remove('dragover');
});

dom.uploadZone.addEventListener('drop', (e) => {
  e.preventDefault();
  dom.uploadZone.classList.remove('dragover');
  uploadFiles(e.dataTransfer.files);
});

dom.uploadInput.addEventListener('change', () => {
  uploadFiles(dom.uploadInput.files);
  dom.uploadInput.value = '';
});

async function uploadFiles(fileList) {
  const formData = new FormData();
  let count = 0;
  for (const f of fileList) {
    if (/\.(e?dsk|img|ima)$/i.test(f.name)) {
      formData.append('files', f, f.name);
      count++;
    }
  }
  if (!count) return;

  setStatus(`Uploading ${count} file(s)...`);
  try {
    await fetch(API + '/upload', { method: 'POST', body: formData });
    setStatus('Upload complete');
    loadDiskList();
  } catch {
    setStatus('Upload failed');
  }
}

// ═══ Read disk modal ═══
dom.readBtn.addEventListener('click', () => {
  dom.readFilename.value = `disk_${new Date().toISOString().slice(0,10).replace(/-/g,'')}_${Date.now() % 10000}.edsk`;
  dom.readModal.classList.add('visible');
});

dom.readCancel.addEventListener('click', () => {
  dom.readModal.classList.remove('visible');
});

dom.readModal.addEventListener('click', (e) => {
  if (e.target === dom.readModal) dom.readModal.classList.remove('visible');
});

dom.readStart.addEventListener('click', () => {
  const filename = dom.readFilename.value.trim() || 'disk.edsk';
  const format = dom.readFormat.value || undefined;
  const revs = parseInt(dom.readRevs.value) || 3;
  const retries = parseInt(dom.readRetries.value) || 3;

  dom.readModal.classList.remove('visible');
  state.reading = true;
  document.body.classList.add('reading');
  dom.readBtn.disabled = true;
  dom.readProgress.innerHTML = '';
  dom.readProgress.classList.add('active');

  wsSend({ action: 'read-disk', filename, format, revs, retries });
});

// ═══ Context menu ═══
window.showCtxMenu = function(e, name) {
  e.preventDefault();
  e.stopPropagation();
  state.ctxTarget = name;
  dom.ctxMenu.style.left = e.clientX + 'px';
  dom.ctxMenu.style.top = e.clientY + 'px';
  dom.ctxMenu.classList.add('visible');
};

document.addEventListener('click', () => {
  dom.ctxMenu.classList.remove('visible');
});

dom.ctxReload.addEventListener('click', () => {
  if (state.ctxTarget) selectDisk(state.ctxTarget);
});

dom.ctxDelete.addEventListener('click', async () => {
  if (!state.ctxTarget) return;
  if (!confirm(`Delete ${state.ctxTarget}?`)) return;

  try {
    await fetch(API + `/api/disk/${encodeURIComponent(state.ctxTarget)}`, { method: 'DELETE' });
    if (state.activeDisk === state.ctxTarget) {
      state.activeDisk = null;
      state.diskData = null;
      dom.diskHeader.classList.remove('visible');
      dom.tabBar.classList.remove('visible');
      $$('.tab-content').forEach(c => c.classList.remove('active'));
      dom.emptyState.style.display = '';
    }
    loadDiskList();
    setStatus(`Deleted ${state.ctxTarget}`);
  } catch {
    setStatus('Delete failed');
  }
});

// ═══ Keyboard shortcuts ═══
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    dom.readModal.classList.remove('visible');
    dom.ctxMenu.classList.remove('visible');
  }
});

// ═══ Init ═══
async function init() {
  connectWS();
  await Promise.all([checkGW(), loadDiskList()]);
  // Refresh GW status every 10s
  setInterval(checkGW, 10000);
}

init();
</script>
</body>
</html>
